"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestIdOf = exports.hash = exports.toHex = void 0;
const js_sha256_1 = require("js-sha256");
const borc_1 = __importDefault(require("borc"));
const buffer_1 = require("buffer/");
const types_1 = require("./types");
const leb128_1 = require("./utils/leb128");
/**
 * get RequestId as hex-encoded blob.
 * @param requestId - RequestId to hex
 */
function toHex(requestId) {
    return types_1.blobToHex(requestId);
}
exports.toHex = toHex;
/**
 * sha256 hash the provided Buffer
 * @param data - input to hash function
 */
function hash(data) {
    const hashed = js_sha256_1.sha256.create().update(data).arrayBuffer();
    return types_1.blobFromUint8Array(new Uint8Array(hashed));
}
exports.hash = hash;
function hashValue(value) {
    if (value instanceof borc_1.default.Tagged) {
        return hashValue(value.value);
    }
    else if (typeof value === 'string') {
        return hashString(value);
    }
    else if (typeof value === 'number') {
        return hash(leb128_1.lebEncode(value));
    }
    else if (buffer_1.Buffer.isBuffer(value)) {
        return hash(types_1.blobFromUint8Array(new Uint8Array(value)));
    }
    else if (value instanceof Uint8Array || value instanceof ArrayBuffer) {
        return hash(types_1.blobFromUint8Array(new Uint8Array(value)));
    }
    else if (Array.isArray(value)) {
        const vals = value.map(hashValue);
        return hash(buffer_1.Buffer.concat(vals));
    }
    else if (typeof value === 'object' &&
        value !== null &&
        typeof value.toHash === 'function') {
        return hashValue(value.toHash());
        // TODO This should be move to a specific async method as the webauthn flow required
        // the flow to be synchronous to ensure Safari touch id works.
        // } else if (value instanceof Promise) {
        //   return value.then(x => hashValue(x));
    }
    else if (typeof value === 'bigint') {
        // Do this check much later than the other bigint check because this one is much less
        // type-safe.
        // So we want to try all the high-assurance type guards before this 'probable' one.
        return hash(leb128_1.lebEncode(value));
    }
    throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {
        // include so logs/callers can understand the confusing value.
        // (when stringified in error message, prototype info is lost)
        value,
    });
}
const hashString = (value) => {
    const encoder = new TextEncoder();
    const encoded = encoder.encode(value);
    return hash(buffer_1.Buffer.from(encoded));
};
/**
 * Concatenate many blobs.
 * @param bs - blobs to concatenate
 */
function concat(bs) {
    return types_1.blobFromBuffer(buffer_1.Buffer.concat(bs));
}
/**
 * Get the RequestId of the provided ic-ref request.
 * RequestId is the result of the representation-independent-hash function.
 * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map
 * @param request - ic-ref request to hash into RequestId
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function requestIdOf(request) {
    const hashed = Object.entries(request)
        .filter(([, value]) => value !== undefined)
        .map(([key, value]) => {
        const hashedKey = hashString(key);
        const hashedValue = hashValue(value);
        return [hashedKey, hashedValue];
    });
    const traversed = hashed;
    const sorted = traversed.sort(([k1], [k2]) => {
        return buffer_1.Buffer.compare(buffer_1.Buffer.from(k1), buffer_1.Buffer.from(k2));
    });
    const concatenated = concat(sorted.map(concat));
    const requestId = hash(concatenated);
    return requestId;
}
exports.requestIdOf = requestIdOf;
//# sourceMappingURL=request_id.js.map